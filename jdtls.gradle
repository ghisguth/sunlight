// jdtls.gradle - Standalone JDTLS/Eclipse classpath generator for Android projects.
// Usage: ./gradlew -I jdtls.gradle syncJdtlsClasspaths
// This file is NOT part of the normal build. It is only used by the Neovim JDTLS integration.

initscript {
    // no dependencies needed
}

allprojects {
    afterEvaluate {
        // Only register once on root project
        if (project == rootProject) {
            tasks.register('syncJdtlsClasspaths') {
                group = 'ide'
                description = 'Generates Eclipse .classpath/.project/.settings for JDTLS Android support'

                doLast {
                    rootProject.subprojects.each { proj ->
                        def hasAndroid = proj.plugins.hasPlugin('com.android.application') || proj.plugins.hasPlugin('com.android.library')
                        if (!hasAndroid) return

                        // 1. Generate .project (pure Java nature, no Buildship)
                        def projectFile = new File(proj.projectDir, '.project')
                        projectFile.text = """\
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
\t<name>${proj.name}</name>
\t<comment></comment>
\t<projects></projects>
\t<buildSpec>
\t\t<buildCommand>
\t\t\t<name>org.eclipse.jdt.core.javabuilder</name>
\t\t\t<arguments></arguments>
\t\t</buildCommand>
\t</buildSpec>
\t<natures>
\t\t<nature>org.eclipse.jdt.core.javanature</nature>
\t</natures>
</projectDescription>"""

                        // 2. Generate .settings/org.eclipse.jdt.core.prefs (suppress warnings)
                        def settingsDir = new File(proj.projectDir, '.settings')
                        settingsDir.mkdirs()
                        def prefsFile = new File(settingsDir, 'org.eclipse.jdt.core.prefs')
                        prefsFile.text = """\
eclipse.preferences.version=1
org.eclipse.jdt.core.compiler.problem.unusedLocal=ignore
org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=ignore
org.eclipse.jdt.core.compiler.problem.unusedImport=warning
org.eclipse.jdt.core.compiler.problem.deadCode=ignore
org.eclipse.jdt.core.compiler.problem.forbiddenReference=ignore
org.eclipse.jdt.core.compiler.problem.deprecation=ignore
org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=ignore
org.eclipse.jdt.core.compiler.source=21
org.eclipse.jdt.core.compiler.compliance=21
org.eclipse.jdt.core.compiler.codegen.targetPlatform=21
"""

                        // 3. Generate .classpath
                        def classpathFile = new File(proj.projectDir, '.classpath')
                        def testEntry = proj.file('test').exists() ? '\n\t<classpathentry kind="src" path="test"/>' : ''

                        // Resolve Android SDK from environment
                        def sdkDir = System.getenv('ANDROID_HOME') ?: System.getenv('ANDROID_SDK_ROOT')
                        if (!sdkDir) {
                            throw new GradleException("ANDROID_HOME is not set. Please set it in your shell profile:\nexport ANDROID_HOME=\"\$HOME/Library/Android/sdk\"")
                        }
                        if (!new File(sdkDir).exists()) {
                            throw new GradleException("ANDROID_HOME points to non-existent directory: ${sdkDir}")
                        }
                        def compileSdk = proj.android.compileSdk ?: 36
                        def androidJarPath = new File(sdkDir, "platforms/android-${compileSdk}/android.jar").absolutePath

                        def extraLibs = ""
                        if (new File(androidJarPath).exists()) {
                            extraLibs += "\n\t<classpathentry kind=\"lib\" path=\"${androidJarPath}\"/>"
                        } else {
                            println "WARNING: android.jar not found at ${androidJarPath} â€” run 'sdkmanager \"platforms;android-${compileSdk}\"'"
                        }

                        // R.jar from AGP build intermediates
                        def rJarCompile = new File(proj.projectDir, "build/intermediates/compile_r_class_jar/debug/generateDebugRFile/R.jar")
                        def rJarRuntime = new File(proj.projectDir, "build/intermediates/compile_and_runtime_r_class_jar/debug/processDebugResources/R.jar")
                        if (rJarCompile.exists()) {
                            extraLibs += "\n\t<classpathentry exported=\"true\" kind=\"lib\" path=\"${rJarCompile.absolutePath}\"/>"
                        } else if (rJarRuntime.exists()) {
                            extraLibs += "\n\t<classpathentry exported=\"true\" kind=\"lib\" path=\"${rJarRuntime.absolutePath}\"/>"
                        }

                        // Also add R.jar from dependency projects (cross-module R resolution)
                        proj.configurations.implementation.dependencies.withType(ProjectDependency).each { dep ->
                            def depProj = rootProject.findProject(":${dep.name}")
                            if (depProj) {
                                def depRJar = new File(depProj.projectDir, "build/intermediates/compile_r_class_jar/debug/generateDebugRFile/R.jar")
                                if (depRJar.exists()) {
                                    extraLibs += "\n\t<classpathentry exported=\"true\" kind=\"lib\" path=\"${depRJar.absolutePath}\"/>"
                                }
                            }
                        }

                        // Inter-project source dependencies
                        def projectDepsXml = ""
                        proj.configurations.implementation.dependencies.withType(ProjectDependency).each { dep ->
                            projectDepsXml += "\n\t<classpathentry kind=\"src\" path=\"/${dep.name}\" combineAccessRules=\"false\"/>"
                        }

                        // External library JARs (AndroidX, JUnit, etc.) via artifact transform
                        def libDepsXml = ""
                        def addedLibs = [] as Set
                        def addConfig = { configName ->
                            def config = proj.configurations.findByName(configName)
                            if (config) {
                                try {
                                    def artifactType = Attribute.of('artifactType', String)
                                    def view = config.incoming.artifactView {
                                        attributes { it.attribute(artifactType, 'android-classes-jar') }
                                        lenient(true)
                                    }
                                    view.files.each { f ->
                                        if (!addedLibs.contains(f.absolutePath) && f.exists()) {
                                            addedLibs.add(f.absolutePath)
                                            libDepsXml += "\n\t<classpathentry kind=\"lib\" path=\"${f.absolutePath}\"/>"
                                        }
                                    }
                                } catch (Exception e) {
                                    println "Warning: could not resolve ${configName} for ${proj.name}: ${e.message}"
                                }
                            }
                        }
                        addConfig("debugCompileClasspath")
                        addConfig("debugUnitTestCompileClasspath")

                        classpathFile.text = """\
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
\t<classpathentry kind="src" path="src"/>${testEntry}
\t<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-21/"/>${extraLibs}${projectDepsXml}${libDepsXml}
\t<classpathentry kind="output" path="bin/default"/>
</classpath>"""

                        println "Generated JDTLS metadata for :${proj.name}"
                    }

                    // Also generate root .project
                    def rootProjectFile = new File(rootProject.projectDir, '.project')
                    if (!rootProjectFile.exists()) {
                        rootProjectFile.text = """\
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
\t<name>${rootProject.name}</name>
\t<comment></comment>
\t<projects></projects>
\t<buildSpec></buildSpec>
\t<natures></natures>
</projectDescription>"""
                    }

                    println "JDTLS sync complete!"
                }
            }
        }
    }
}
